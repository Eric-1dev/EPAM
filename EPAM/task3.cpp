/*
 * Не совсем понимаю, что считать готовыми библиотечными функциями языка.
 * Например str.substr() можно было заменить на посимвольное копирование.
 * С другой стороны - это метод класса string, такой же, как перегруженный оператор ==,
 * который уже существует у объекта класса string.
*/

#include <iostream>
#include <vector>
#include <string>
#include "tasks.h"

using namespace std;

void task3() {
	cout << "Строки" << endl << endl;

	vector<string> word_arr;

	string str = "Российские власти склоняются к ужесточению карантина в стране \
и принятию новых мер по выявлению коронавируса. Также хотят нарастить \
тестирование тех, кто контактировал с заболевшими, для последующей изоляции. \
Об этом сообщают РИА \"Новости\" со ссылкой на источник в правительстве РФ. \
По словам собеседника агентства, скорость распространения инфекции в России \
математически соответсвует ситуации в таких странах как Испания, Франция, \
Великобритания и Германия. Ежедневно это прирост от 27 % до 33 %. Чтобы \
сократить рост заболевших, требуется предпринимать решительные меры по карантину, \
заявил источник. При этом он отметил, что у России пока что есть запас времени \
для принятия жестких мер. По его словам, российские власти продолжат тщательно \
анализировать информацию о мерах по сдерживанию коронавируса.";

	cout << "Исходная строка:\n" + str << endl;

	/*
	 * Сначала разобьем строку на слова и запишем их в вектор.
	 * Для этого перебираем символы и ищем те, которые разделяют слова:
	 * пробелы и знаки препинания. Запоминаем позицию первого символа слова (spos)
	 * и его длину (j). Потом копируем слово в вектор.
	*/
	unsigned short int j = 0;
	uint16_t spos;
	for (uint16_t i = 0; i < str.length(); i++) {
		if (str[i] != ' ' && str[i] != ',' && str[i] != '.' && str[i] != '!' && str[i] != '?') {
			if (j == 0)
				spos = i;
			j++;
		}
		else {
			if (j) {
				word_arr.push_back(str.substr(spos, j));
				j = 0;
			}
		}
	}

	cout << "\nСлова, встречающиеся только один раз:\n" << endl;

	// Теперь сравниваем каждое слово с последующими и выводим, если оно не повторяется
	bool flag;
	for (uint16_t i = 0; i < word_arr.size() - 1; ++i) {
		flag = true;
		for (uint16_t j = i + 1; j < word_arr.size(); ++j) {
			if (word_arr[i] == word_arr[j])
				flag = false;
		}
		if (flag)
			cout << word_arr[i] << " ";
	}
	cout << endl;
}